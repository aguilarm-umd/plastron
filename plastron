#!/usr/bin/env python3
#-*- coding: utf-8 -*-

from __future__ import print_function

import argparse
from importlib import import_module
import os.path
import sys
import yaml
import logging
import logging.config
from datetime import datetime
from classes import pcdm
from classes.exceptions import FailureException

logger = logging.getLogger(__name__)
now = datetime.utcnow().strftime('%Y%m%d%H%M%S')

# custom argument type for percentage loads
def percentage(n):
    p = int(n)
    if not p > 0 and p < 100:
        raise argparse.ArgumentTypeError("Percent param must be 1-99")
    return p

#============================================================================
# MAIN LOOP
#============================================================================

def main():
    '''Parse args and handle options.'''

    parser = argparse.ArgumentParser(
        description='A configurable batch loader for Fedora 4.'
        )
    common_required = parser.add_argument_group('required arguments')
    common_required.add_argument('-r', '--repo',
                        help='Path to repository configuration file.',
                        action='store',
                        required=True
                        )
    parser.add_argument('-v', '--verbose',
                        help='increase the verbosity of the status output',
                        action='store_true'
                        )
    parser.add_argument('-q', '--quiet',
                        help='decrease the verbosity of the status output',
                        action='store_true'
                        )

    subparsers = parser.add_subparsers()

    parser_ping = subparsers.add_parser('ping')
    parser_ping.set_defaults(cmd_name='ping')

    parser_load = subparsers.add_parser('load')
    required = parser_load.add_argument_group('required arguments')
    required.add_argument('-b', '--batch',
                        help='path to batch configuration file',
                        action='store',
                        required=True
                        )
    parser_load.add_argument('-d', '--dryrun',
                        help='iterate over the batch without POSTing',
                        action='store_true'
                        )
    # useful for testing when file loading is too slow
    parser_load.add_argument('-n', '--nobinaries',
                        help='iterate without uploading binaries',
                        action='store_true'
                        )
    parser_load.add_argument('-l', '--limit',
                        help='limit the load to a specified number of top-level objects',
                        action='store',
                        type=int,
                        default=None
                        )
    # load an evenly-spaced percentage of the total batch
    parser_load.add_argument('-%', '--percent',
                        help='load specified percentage of total items',
                        action='store',
                        type=percentage,
                        default=None
                        )
    parser_load.add_argument('--noannotations',
                        help='iterate without loading annotations (e.g. OCR)',
                        action='store_true'
                        )
    parser_load.add_argument('--ignore', '-i',
                        help='file listing items to ignore',
                        action='store'
                        )
    parser_load.add_argument('--wait', '-w',
                        help='wait n seconds between items',
                        action='store'
                        )
    parser_load.set_defaults(cmd_name='load')

    parser_list = subparsers.add_parser('list', aliases=['ls'])
    # long mode to print more than just the URIs (name modeled after ls -l)
    parser_list.add_argument('-l', '--long',
                        help='Display additional information besides the URI',
                        action='store_true'
                        )
    parser_list.add_argument('-R', '--recursive',
                        help='List additional objects found by traversing the given predicate(s)',
                        action='store'
                        )
    parser_list.add_argument('uris', nargs='*',
                        help='URIs of repository objects to list'
                        )
    parser_list.set_defaults(cmd_name='list')

    parser_mkcol = subparsers.add_parser('mkcol')
    parser_mkcol.add_argument('-n', '--name',
                        help='Name of the collection.',
                        action='store',
                        required=True
                        )
    # if given, will write the collection URI to it
    parser_mkcol.add_argument('-b', '--batch',
                        help='Path to batch configuration file.',
                        action='store'
                        )
    parser_mkcol.set_defaults(cmd_name='mkcol')

    parser_delete = subparsers.add_parser('delete', aliases=['del', 'rm'])
    parser_delete.add_argument('-R', '--recursive',
                        help='Delete additional objects found by traversing the given predicate(s)',
                        action='store'
                        )
    parser_delete.add_argument('-d', '--dryrun',
                        help='Simulate a delete without modifying the repository',
                        action='store_true'
                        )
    parser_delete.add_argument('-f', '--file',
                        help='File containing a list of URIs to delete',
                        action='store'
                        )
    parser_delete.add_argument('uris', nargs='*',
                        help='Repository URIs to be deleted.'
                        )
    parser_delete.set_defaults(cmd_name='delete')

    parser_extractocr = subparsers.add_parser('extractocr')
    parser_extractocr.add_argument('--ignore', '-i',
                        help='file listing items to ignore',
                        action='store'
                        )
    parser_extractocr.set_defaults(cmd_name='extractocr')

    # parse command line args
    args = parser.parse_args()

    # load required repository config file and create repository object
    with open(args.repo, 'r') as repo_config_file:
        repo_config = yaml.safe_load(repo_config_file)
        fcrepo = pcdm.Repository(repo_config)

    # get basic logging options
    with open('config/logging.yml', 'r') as configfile:
        logging_options = yaml.safe_load(configfile)

    # log file configuration
    log_dirname = repo_config.get('LOG_DIR')
    log_filename = 'plastron.{0}.{1}.log'.format(args.cmd_name, now)
    logfile = os.path.join(log_dirname, log_filename)
    logging_options['handlers']['file']['filename'] = logfile

    # manipulate console verbosity
    if args.verbose:
        logging_options['handlers']['console']['level'] = 'DEBUG'
    elif args.quiet:
        logging_options['handlers']['console']['level'] = 'WARNING'

    # configure logging
    logging.config.dictConfig(logging_options)

    logger.info('Loaded repo configuration from {0}'.format(args.repo))

    command = import_module('command.' + args.cmd_name)

    try:
        # dispatch to the selected subcommand
        command.run(fcrepo, args)
    except FailureException as e:
        # something failed, exit with non-zero status
        sys.exit(1)
    except KeyboardInterrupt as e:
        # aborted due to Ctrl+C
        sys.exit(2)

if __name__ == "__main__":
    main()
